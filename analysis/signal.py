from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, Optional, List
from enum import Enum

class SignalType(Enum):
    LONG = "LONG"
    SHORT = "SHORT"

class SignalStatus(Enum):
    NEW = "NEW"
    PROCESSED = "PROCESSED"
    EXECUTED = "EXECUTED"
    EXPIRED = "EXPIRED"
    REJECTED = "REJECTED"

@dataclass
class Signal:
    """
    Represents a trading signal generated by the Scanner.
    """
    symbol: str
    timestamp: datetime
    type: SignalType
    timeframe: str = "1h"
    
    # Price Data at Trigger
    price: float = 0.0
    atr_value: float = 0.0
    
    # Entry Plan (Calculated later or immediately?)
    # Usually Scanner detects opportunity, RiskManager adds specific prices
    # But basic reference levels are good to have.
    stop_loss: Optional[float] = None
    take_profit_1: Optional[float] = None
    take_profit_2: Optional[float] = None
    take_profit_3: Optional[float] = None
    
    # Entry Orders (Limit levels)
    # E1 is usually Market, E2/E3 Limits
    entry_2_price: Optional[float] = None
    entry_3_price: Optional[float] = None
    
    # Context
    metadata: Dict = field(default_factory=dict)
    # metadata example: {"rsi": 32.5, "adx": 18, "pattern": "Hammer"}
    
    status: SignalStatus = SignalStatus.NEW
    created_at: datetime = field(default_factory=datetime.utcnow)
    
    def __str__(self):
        return f"[{self.type.value}] {self.symbol} @ {self.price} | {self.timestamp}"
