#!/usr/bin/env python3
"""
üöÄ SISTEMA DE TRADING AUTOMATIZADO V2.0 - MAIN ORCHESTRATOR
==========================================================

Sistema completo de trading automatizado que:
- Escanea m√∫ltiples s√≠mbolos cada 15 minutos
- Detecta se√±ales de alta calidad (70+ puntos)
- Calcula planes de posici√≥n adaptativos
- Env√≠a alertas inteligentes por Telegram
- Monitorea performance y maneja errores

Autor: Trading System V2.0
Fecha: Septiembre 2025
Estado: PRODUCCI√ìN READY
"""

import asyncio
import logging
import signal
import sys
import time
from datetime import datetime, timedelta
from typing import Dict, List, Optional
import schedule
import pytz
from pathlib import Path
import traceback
import json

# Importar m√≥dulos del sistema
try:
    import config
    from indicators import TechnicalIndicators
    from scanner import SignalScanner, TradingSignal
    from position_calculator import PositionCalculator
    from telegram_bot import TelegramBot
except ImportError as e:
    print(f"‚ùå Error importando m√≥dulos: {e}")
    print("üí° Aseg√∫rate de que todos los archivos est√°n en el directorio correcto")
    sys.exit(1)

# Configurar logging avanzado
def setup_logging():
    """Configurar sistema de logging completo"""
    try:
        # Crear directorio de logs
        log_dir = Path("logs")
        log_dir.mkdir(exist_ok=True)
        
        # Configurar formato
        log_format = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        
        # Logger principal
        logger = logging.getLogger()
        logger.setLevel(getattr(logging, config.LOG_LEVEL, 'INFO'))
        
        # Handler para consola
        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setLevel(logging.INFO)
        console_handler.setFormatter(log_format)
        logger.addHandler(console_handler)
        
        # Handler para archivo
        file_handler = logging.FileHandler(
            log_dir / config.LOG_FILE,
            encoding='utf-8'
        )
        file_handler.setLevel(logging.DEBUG)
        file_handler.setFormatter(log_format)
        logger.addHandler(file_handler)
        
        return logger
        
    except Exception as e:
        print(f"‚ùå Error configurando logging: {e}")
        # Fallback a logging b√°sico
        logging.basicConfig(level=logging.INFO)
        return logging.getLogger()

# Setup logging
logger = setup_logging()

class TradingSystemOrchestrator:
    """
    Orquestador principal del sistema de trading automatizado
    """
    
    def __init__(self):
        """Inicializar todos los componentes del sistema"""
        self.version = "2.0"
        self.start_time = datetime.now()
        self.running = False
        self.spain_tz = pytz.timezone('Europe/Madrid')
        
        # Componentes del sistema
        self.indicators = None
        self.scanner = None
        self.position_calc = None
        self.telegram_bot = None
        
        # Estad√≠sticas de sesi√≥n
        self.session_stats = {
            'scans_completed': 0,
            'signals_detected': 0,
            'alerts_sent': 0,
            'errors_count': 0,
            'last_scan_time': None,
            'last_signal_time': None,
            'uptime_start': datetime.now()
        }
        
        # Control de ejecuci√≥n
        self.max_consecutive_errors = 5
        self.consecutive_errors = 0
        self.shutdown_requested = False
        
        logger.info("üöÄ TradingSystemOrchestrator inicializado")
    
    def initialize_components(self) -> bool:
        """
        Inicializar todos los componentes del sistema
        
        Returns:
            True si todos se inicializan correctamente
        """
        try:
            logger.info("‚öôÔ∏è Inicializando componentes del sistema...")
            
            # 1. Validar configuraci√≥n
            config_errors = config.validate_config()
            if config_errors:
                logger.error("‚ùå Errores de configuraci√≥n:")
                for error in config_errors:
                    logger.error(f"  {error}")
                return False
            
            logger.info("‚úÖ Configuraci√≥n validada")
            
            # 2. Inicializar indicadores t√©cnicos
            self.indicators = TechnicalIndicators()
            logger.info("‚úÖ Indicadores t√©cnicos inicializados")
            
            # 3. Inicializar scanner de se√±ales
            self.scanner = SignalScanner()
            logger.info("‚úÖ Scanner de se√±ales inicializado")
            
            # 4. Inicializar calculadora de posiciones
            self.position_calc = PositionCalculator()
            logger.info("‚úÖ Calculadora de posiciones inicializada")
            
            # 5. Inicializar bot de Telegram
            self.telegram_bot = TelegramBot()
            if not self.telegram_bot.initialized:
                logger.error("‚ùå Bot de Telegram no se pudo inicializar")
                return False
            
            logger.info("‚úÖ Bot de Telegram inicializado")
            
            # 6. Test de conectividad
            if not self._test_connectivity():
                logger.warning("‚ö†Ô∏è Test de conectividad fall√≥, pero continuando...")
            
            logger.info("üéØ Todos los componentes inicializados correctamente")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error inicializando componentes: {e}")
            logger.error(traceback.format_exc())
            return False
    
    def _test_connectivity(self) -> bool:
        """Test b√°sico de conectividad"""
        try:
            # Test de descarga de datos
            test_data = self.indicators.get_market_data("SPY", "15m", 5)
            if len(test_data) < 10:
                logger.warning("‚ö†Ô∏è Pocos datos descargados en test")
                return False
            
            logger.info(f"‚úÖ Test de datos: {len(test_data)} barras descargadas")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error en test de conectividad: {e}")
            return False
    
    def setup_scheduler(self):
        """Configurar el scheduler para ejecuciones autom√°ticas"""
        try:
            # Limpiar schedule previo
            schedule.clear()
            
            # Programar escaneo principal cada X minutos
            schedule.every(config.SCAN_INTERVAL).minutes.do(self.run_scan_cycle)
            
            # Programar estad√≠sticas cada hora
            schedule.every().hour.do(self.log_hourly_stats)
            
            # Programar resumen diario (opcional)
            if config.ALERT_TYPES.get('DAILY_SUMMARY', False):
                schedule.every().day.at("09:00").do(self.send_daily_summary)
            
            logger.info(f"üìÖ Scheduler configurado - Escaneo cada {config.SCAN_INTERVAL} minutos")
            
        except Exception as e:
            logger.error(f"‚ùå Error configurando scheduler: {e}")
    
    def run_scan_cycle(self) -> Dict:
        """
        Ejecutar un ciclo completo de escaneo
        
        Returns:
            Dict con resultados del ciclo
        """
        cycle_start = time.time()
        cycle_results = {
            'success': False,
            'signals_found': 0,
            'alerts_sent': 0,
            'errors': [],
            'duration': 0,
            'timestamp': datetime.now(self.spain_tz)
        }
        
        try:
            logger.info("üîç Iniciando ciclo de escaneo...")
            
            # 1. Verificar si el mercado est√° abierto
            if not self.scanner.is_market_open() and not config.DEVELOPMENT_MODE:
                logger.info("üì¥ Mercado cerrado - Omitiendo escaneo")
                cycle_results['success'] = True
                return cycle_results
            
            # 2. Ejecutar escaneo de todos los s√≠mbolos
            symbols_to_scan = config.TEST_SYMBOLS if config.TEST_MODE else config.SYMBOLS
            signals = self.scanner.scan_multiple_symbols(symbols_to_scan)
            
            cycle_results['signals_found'] = len(signals)
            logger.info(f"üìä Escaneo completado: {len(signals)} se√±ales detectadas de {len(symbols_to_scan)} s√≠mbolos")
            
            # 3. Procesar y enviar alertas
            alerts_sent = 0
            for signal in signals:
                try:
                    # Enviar alerta por Telegram
                    success = self.telegram_bot.send_signal_alert(signal)
                    if success:
                        alerts_sent += 1
                        logger.info(f"‚úÖ Alerta enviada: {signal.symbol} {signal.signal_type} ({signal.signal_strength} pts)")
                    else:
                        logger.error(f"‚ùå Error enviando alerta: {signal.symbol}")
                        cycle_results['errors'].append(f"Failed to send alert for {signal.symbol}")
                        
                except Exception as e:
                    error_msg = f"Error procesando se√±al {signal.symbol}: {str(e)}"
                    logger.error(error_msg)
                    cycle_results['errors'].append(error_msg)
            
            cycle_results['alerts_sent'] = alerts_sent
            
            # 4. Actualizar estad√≠sticas
            self.session_stats['scans_completed'] += 1
            self.session_stats['signals_detected'] += len(signals)
            self.session_stats['alerts_sent'] += alerts_sent
            self.session_stats['last_scan_time'] = datetime.now()
            
            if signals:
                self.session_stats['last_signal_time'] = datetime.now()
            
            # 5. Reset contador de errores consecutivos
            if not cycle_results['errors']:
                self.consecutive_errors = 0
            
            cycle_results['success'] = True
            cycle_results['duration'] = time.time() - cycle_start
            
            logger.info(f"‚úÖ Ciclo completado en {cycle_results['duration']:.1f}s - {alerts_sent} alertas enviadas")
            
        except Exception as e:
            error_msg = f"Error en ciclo de escaneo: {str(e)}"
            logger.error(error_msg)
            logger.error(traceback.format_exc())
            
            cycle_results['errors'].append(error_msg)
            self.session_stats['errors_count'] += 1
            self.consecutive_errors += 1
            
            # Enviar alerta de error cr√≠tico
            if self.consecutive_errors >= 3:
                self._send_error_alert(f"Error cr√≠tico en ciclo #{self.consecutive_errors}: {str(e)}")
        
        return cycle_results
    
    def _send_error_alert(self, error_message: str):
        """Enviar alerta de error cr√≠tico"""
        try:
            if self.telegram_bot and self.telegram_bot.initialized:
                self.telegram_bot.send_system_alert("ERROR", error_message)
        except Exception as e:
            logger.error(f"Error enviando alerta de error: {e}")
    
    def log_hourly_stats(self):
        """Registrar estad√≠sticas cada hora"""
        try:
            uptime = datetime.now() - self.session_stats['uptime_start']
            
            stats_message = (
                f"üìä ESTAD√çSTICAS HORARIAS\n"
                f"‚è∞ Uptime: {uptime}\n"
                f"üîç Escaneos: {self.session_stats['scans_completed']}\n"
                f"üéØ Se√±ales: {self.session_stats['signals_detected']}\n"
                f"üì± Alertas: {self.session_stats['alerts_sent']}\n"
                f"‚ùå Errores: {self.session_stats['errors_count']}\n"
                f"üí™ Estado: {'üü¢ Operativo' if self.consecutive_errors < 3 else 'üü° Degradado'}"
            )
            
            logger.info(stats_message)
            
            # Enviar por Telegram si est√° configurado
            if config.ALERT_TYPES.get('SYSTEM_INFO', False):
                self.telegram_bot.send_system_alert("INFO", stats_message)
                
        except Exception as e:
            logger.error(f"Error en estad√≠sticas horarias: {e}")
    
    def send_daily_summary(self):
        """Enviar resumen diario (opcional)"""
        try:
            if not config.ALERT_TYPES.get('DAILY_SUMMARY', False):
                return
            
            summary = (
                f"üìà RESUMEN DIARIO\n"
                f"üîç Total escaneos: {self.session_stats['scans_completed']}\n"
                f"üéØ Total se√±ales: {self.session_stats['signals_detected']}\n"
                f"üì± Total alertas: {self.session_stats['alerts_sent']}\n"
                f"üìä Tasa detecci√≥n: {(self.session_stats['signals_detected'] / max(self.session_stats['scans_completed'], 1)):.1%}\n"
                f"‚úÖ Sistema funcionando correctamente"
            )
            
            self.telegram_bot.send_system_alert("INFO", summary)
            logger.info("üìà Resumen diario enviado")
            
        except Exception as e:
            logger.error(f"Error enviando resumen diario: {e}")
    
    def run_forever(self):
        """
        Ejecutar el sistema de forma continua
        """
        try:
            logger.info("üöÄ Iniciando sistema de trading automatizado...")
            
            # Enviar mensaje de inicio
            startup_message = (
                f"üöÄ Sistema Trading v{self.version} INICIADO\n"
                f"üìä S√≠mbolos: {', '.join(config.SYMBOLS)}\n"
                f"‚è∞ Intervalo: {config.SCAN_INTERVAL} min\n"
                f"üéØ Umbral m√≠nimo: {config.SIGNAL_THRESHOLDS['NO_TRADE']} pts\n"
                f"üí∞ Riesgo por trade: {config.RISK_PER_TRADE}%\n"
                f"üèõÔ∏è Mercado: {'üü¢ Abierto' if self.scanner.is_market_open() else 'üî¥ Cerrado'}"
            )
            
            self.telegram_bot.send_system_alert("START", startup_message)
            
            self.running = True
            logger.info("‚úÖ Sistema iniciado correctamente - Entrando en loop principal")
            
            # Loop principal
            while self.running and not self.shutdown_requested:
                try:
                    # Ejecutar tareas programadas
                    schedule.run_pending()
                    
                    # Verificar si hay demasiados errores consecutivos
                    if self.consecutive_errors >= self.max_consecutive_errors:
                        logger.error(f"‚ùå Demasiados errores consecutivos ({self.consecutive_errors}). Deteniendo sistema.")
                        self._send_error_alert(f"Sistema detenido por {self.consecutive_errors} errores consecutivos")
                        break
                    
                    # Dormir 1 segundo antes de siguiente iteraci√≥n
                    time.sleep(1)
                    
                except KeyboardInterrupt:
                    logger.info("‚ö†Ô∏è Interrupci√≥n del usuario detectada")
                    break
                except Exception as e:
                    logger.error(f"‚ùå Error en loop principal: {e}")
                    self.session_stats['errors_count'] += 1
                    time.sleep(5)  # Esperar antes de continuar
            
        except Exception as e:
            logger.error(f"‚ùå Error cr√≠tico en run_forever: {e}")
            logger.error(traceback.format_exc())
        finally:
            self._shutdown_system()
    
    def run_single_scan(self) -> Dict:
        """
        Ejecutar un solo escaneo (√∫til para testing)
        
        Returns:
            Resultados del escaneo
        """
        logger.info("üß™ Ejecutando escaneo √∫nico...")
        return self.run_scan_cycle()
    
    def get_system_status(self) -> Dict:
        """Obtener estado completo del sistema"""
        try:
            uptime = datetime.now() - self.session_stats['uptime_start']
            
            # Estado de componentes
            components_status = {
                'indicators': self.indicators is not None,
                'scanner': self.scanner is not None,
                'position_calc': self.position_calc is not None,
                'telegram_bot': self.telegram_bot and self.telegram_bot.initialized
            }
            
            return {
                'version': self.version,
                'running': self.running,
                'uptime': str(uptime),
                'uptime_seconds': uptime.total_seconds(),
                'components': components_status,
                'market_open': self.scanner.is_market_open() if self.scanner else False,
                'consecutive_errors': self.consecutive_errors,
                'session_stats': self.session_stats.copy(),
                'development_mode': config.DEVELOPMENT_MODE,
                'test_mode': config.TEST_MODE
            }
            
        except Exception as e:
            logger.error(f"Error obteniendo estado del sistema: {e}")
            return {'error': str(e)}
    
    def _shutdown_system(self):
        """Apagar el sistema de forma ordenada"""
        try:
            logger.info("üõë Iniciando apagado del sistema...")
            
            self.running = False
            
            # Limpiar scheduler
            schedule.clear()
            
            # Enviar mensaje de apagado
            if self.telegram_bot and self.telegram_bot.initialized:
                uptime = datetime.now() - self.session_stats['uptime_start']
                shutdown_message = (
                    f"üõë Sistema DETENIDO\n"
                    f"‚è∞ Uptime: {uptime}\n"
                    f"üìä Estad√≠sticas finales:\n"
                    f"  ‚Ä¢ Escaneos: {self.session_stats['scans_completed']}\n"
                    f"  ‚Ä¢ Se√±ales: {self.session_stats['signals_detected']}\n"
                    f"  ‚Ä¢ Alertas: {self.session_stats['alerts_sent']}\n"
                    f"  ‚Ä¢ Errores: {self.session_stats['errors_count']}"
                )
                
                self.telegram_bot.send_system_alert("INFO", shutdown_message)
            
            logger.info("‚úÖ Sistema apagado correctamente")
            
        except Exception as e:
            logger.error(f"Error en apagado del sistema: {e}")
    
    def _signal_handler(self, signum, frame):
        """Manejador de se√±ales del sistema (Ctrl+C, etc.)"""
        logger.info(f"üì° Se√±al {signum} recibida - Iniciando apagado ordenado...")
        self.shutdown_requested = True


# =============================================================================
# üéØ FUNCIONES DE CONTROL Y UTILIDADES
# =============================================================================

def print_banner():
    """Mostrar banner de inicio"""
    banner = """
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                              ‚ïë
‚ïë          üöÄ SISTEMA DE TRADING AUTOMATIZADO V2.0             ‚ïë
‚ïë                                                              ‚ïë
‚ïë          üìä Detecci√≥n Inteligente de Se√±ales                 ‚ïë
‚ïë          üí∞ Gesti√≥n Adaptativa de Posiciones                 ‚ïë
‚ïë          üì± Alertas Autom√°ticas por Telegram                 ‚ïë
‚ïë                                                              ‚ïë
‚ïë          Estado: PRODUCCI√ìN READY                            ‚ïë
‚ïë                                                              ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    """
    print(banner)

def run_tests():
    """Ejecutar tests de todos los m√≥dulos"""
    print("üß™ EJECUTANDO TESTS DEL SISTEMA COMPLETO")
    print("=" * 60)
    
    try:
        # Test de importaciones
        print("1Ô∏è‚É£ Verificando importaciones...")
        assert config is not None
        assert TechnicalIndicators is not None
        assert SignalScanner is not None
        assert TelegramBot is not None
        print("‚úÖ Todas las importaciones OK")
        
        # Test de configuraci√≥n
        print("\n2Ô∏è‚É£ Validando configuraci√≥n...")
        config_errors = config.validate_config()
        if config_errors:
            print("‚ùå Errores de configuraci√≥n:")
            for error in config_errors:
                print(f"  {error}")
            return False
        print("‚úÖ Configuraci√≥n v√°lida")
        
        # Test de inicializaci√≥n
        print("\n3Ô∏è‚É£ Testeando inicializaci√≥n del sistema...")
        system = TradingSystemOrchestrator()
        init_success = system.initialize_components()
        
        if not init_success:
            print("‚ùå Error en inicializaci√≥n de componentes")
            return False
        print("‚úÖ Todos los componentes inicializados")
        
        # Test de escaneo
        print("\n4Ô∏è‚É£ Ejecutando test de escaneo...")
        scan_result = system.run_single_scan()
        print(f"‚úÖ Escaneo completado: {scan_result['signals_found']} se√±ales")
        
        # Test de estado del sistema
        print("\n5Ô∏è‚É£ Verificando estado del sistema...")
        status = system.get_system_status()
        print(f"‚úÖ Sistema operativo: {status['running']}")
        
        print(f"\nüéØ TODOS LOS TESTS PASARON")
        print(f"üöÄ Sistema listo para producci√≥n")
        return True
        
    except Exception as e:
        print(f"‚ùå Error en tests: {e}")
        return False

def interactive_menu():
    """Men√∫ interactivo para control del sistema"""
    print("\nüéõÔ∏è MEN√ö DE CONTROL DEL SISTEMA")
    print("=" * 40)
    print("1. Ejecutar tests completos")
    print("2. Escaneo √∫nico (test)")
    print("3. Mostrar configuraci√≥n")
    print("4. Iniciar sistema autom√°tico")
    print("5. Estado del sistema")
    print("6. Salir")
    print("")
    
    while True:
        try:
            choice = input("Selecciona una opci√≥n (1-6): ").strip()
            
            if choice == "1":
                print("\n" + "="*60)
                success = run_tests()
                if not success:
                    print("‚ùå Algunos tests fallaron")
                input("\nPresiona Enter para continuar...")
                
            elif choice == "2":
                print("\n" + "="*60)
                system = TradingSystemOrchestrator()
                if system.initialize_components():
                    result = system.run_single_scan()
                    print(f"\nüìä Resultados: {result}")
                else:
                    print("‚ùå Error inicializando sistema")
                input("\nPresiona Enter para continuar...")
                
            elif choice == "3":
                print("\n" + "="*60)
                config.print_config_summary()
                input("\nPresiona Enter para continuar...")
                
            elif choice == "4":
                print("\nüöÄ Iniciando sistema autom√°tico...")
                print("üí° Usa Ctrl+C para detener el sistema")
                system = TradingSystemOrchestrator()
                if system.initialize_components():
                    system.setup_scheduler()
                    system.run_forever()
                else:
                    print("‚ùå Error inicializando sistema")
                    input("\nPresiona Enter para continuar...")
                
            elif choice == "5":
                print("\n" + "="*60)
                system = TradingSystemOrchestrator()
                if system.initialize_components():
                    status = system.get_system_status()
                    print("üìä Estado del Sistema:")
                    for key, value in status.items():
                        print(f"  {key}: {value}")
                else:
                    print("‚ùå Error obteniendo estado")
                input("\nPresiona Enter para continuar...")
                
            elif choice == "6":
                print("üëã ¬°Hasta luego!")
                break
                
            else:
                print("‚ùå Opci√≥n no v√°lida")
            
            # Volver a mostrar men√∫
            print("\nüéõÔ∏è MEN√ö DE CONTROL DEL SISTEMA")
            print("=" * 40)
            print("1. Ejecutar tests completos")
            print("2. Escaneo √∫nico (test)")
            print("3. Mostrar configuraci√≥n")
            print("4. Iniciar sistema autom√°tico") 
            print("5. Estado del sistema")
            print("6. Salir")
            print("")
                
        except KeyboardInterrupt:
            print("\nüëã Saliendo del men√∫...")
            break
        except Exception as e:
            print(f"‚ùå Error: {e}")

# =============================================================================
# üöÄ PUNTO DE ENTRADA PRINCIPAL
# =============================================================================

def main():
    """Funci√≥n principal del sistema"""
    try:
        # Mostrar banner
        print_banner()
        
        # Verificar argumentos de l√≠nea de comandos
        if len(sys.argv) > 1:
            command = sys.argv[1].lower()
            
            if command == "test":
                logger.info("üß™ Modo test solicitado")
                success = run_tests()
                sys.exit(0 if success else 1)
                
            elif command == "scan":
                logger.info("üîç Escaneo √∫nico solicitado")
                system = TradingSystemOrchestrator()
                if system.initialize_components():
                    result = system.run_single_scan()
                    print(f"üìä Resultado: {result}")
                    sys.exit(0)
                else:
                    sys.exit(1)
                    
            elif command == "auto":
                logger.info("üöÄ Modo autom√°tico solicitado")
                system = TradingSystemOrchestrator()
                if system.initialize_components():
                    system.setup_scheduler()
                    
                    # Configurar manejador de se√±ales
                    signal.signal(signal.SIGINT, system._signal_handler)
                    signal.signal(signal.SIGTERM, system._signal_handler)
                    
                    system.run_forever()
                    sys.exit(0)
                else:
                    sys.exit(1)
                    
            elif command == "config":
                config.print_config_summary()
                sys.exit(0)
                
            else:
                print(f"‚ùå Comando desconocido: {command}")
                print("üí° Comandos disponibles: test, scan, auto, config")
                sys.exit(1)
        
        else:
            # Modo interactivo por defecto
            logger.info("üéõÔ∏è Iniciando modo interactivo")
            interactive_menu()
    
    except KeyboardInterrupt:
        logger.info("üëã Sistema interrumpido por el usuario")
        sys.exit(0)
    except Exception as e:
        logger.error(f"‚ùå Error cr√≠tico en main: {e}")
        logger.error(traceback.format_exc())
        sys.exit(1)

if __name__ == "__main__":
    main()